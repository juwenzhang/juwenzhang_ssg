# http 文档
## OSI 七层模型
### OSI 是什么呐？？
* OSI(open systems interface) 模型，开发式通信系统互联参考模型
* OSI 将计算机网络结构划分为了七层结构，每一层就拥有了自己对应的功能和协议，
  * 并且完成相邻层的接口通信，即是说每一层的话扮演着对应不同的角色，互不干扰吧
* 具体划分 
  * `物理层` Physical Layer
  * `数据链路层` Data Link Layer
  * `网络层` Network Layer
  * `传输层` Transport Layer
  * `会话层` Session Layer
  * `表示层` Presentation Layer
  * `应用层` Application Layer

### 应用层(Application Layer)
* 应用层位于我们的 OSI 模型的第七层，其作用是`通过应用程序间的交互完成特定的网络应用`
* 该层定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务
  * 域名系统 DNS -- `Domain Name System`，支持万维网应用的 http 协议，电子邮件采用的是 SMTP 协议
  * 在我们的应用层之间进行交互的数据单元就是我们常说的 `报问`

### 表示层（Presentation Layer）
* 表示层是我们的 OSI 模型的第六层，他的作用是`使通信的应用程序之间能够解析交换数据的含义`
* 该层主要为我们提供的服务含有: `数据压缩`, `数据加密`, `数据描述`, `数据格式转换`，
  * 从而实现我们的不用担心在网络交互中的计算机的表示和存储的内部格式的差异吧

### 会话层（Session Layer）
* 会话层是 OSI 模型的第五层，其作用是`建立、维护和终止表示层实体之间的通信会话`
* 该层提供了数据交换的定界和同步功能，包含了建立检查点和回复方案的方法
  * 主要提供的服务含有: 
    * `会话管理`，`会话同步`，`会话控制`，`会话跟踪`，`会话认证`

### 传输层（Transport Layer）
* 传输层是 OSI 模型的第四层，其作用是`为两台主机之间的通信提供服务，处理数据包错误，数据包次序，以及其他的传输问题`
* 该层提供了数据传输的机制，包含了数据传输的协议，如 `TCP` 和 `UDP`

### 网络层（Network Layer）
* 网络层是 OSI 模型的第三层，两台主机之间进行传输数据的话，其通信链路可不止一条，所传输的信息甚至经过了很多的通信子网
* 网络层的主要作用是: `选择合适的网间路由和交换节点，确保数据按时成功传送`
  * 网络层将传输层的数据封装成了分`组`和`包`
* 在网络层使用的协议是无连接的网络协议`（Internet work Protocols without Connection）` 和 许多路由协议，也是我们的 IP 层

### 数据链路层（Data Link Layer）
* 数据链路层是 OSI 模型的第二层，其作用是`为数据链路提供传输服务，如差错校验，流量控制，分组控制，分组分片等`
* 数据链路层将网络层交下来的 IP 数据组成帧，在两个相邻节点间的链路上传送帧
* 每一帧的数据可以分为: 报头`Head`， 和数据`Data`
  * `head` 标明数据的发送者，接收者，数据类型，数据长度等，`MAC`地址
  * `data` 存储在计算机之间交互的数据

### 物理层（Physical Layer）
* 物理层是 OSI 模型的第一层，其作用是`定义物理连接，如数据线，电缆，光纤，无线电等`
* 就是属于硬件的部分，是计算机与计算机之间进行通信的基础，我们软件工程师不必太清楚，数据的传输嘶 `比特`

---
## TCP/IP 协议
### TCP/IP 是什么呐？？？
* TCP/IP 是一个协议簇，`传输控制协议/网际协议`
* TCP(传输控制协议)
  * 一种面向连接的，可靠的，基于字节流的传输层通信协议
* IP(网际协议)
  * 用于实现的是封包交换数据网络的协议
* 其组成
  * TCP/IP 是一个协议簇，由 `FTP`, `SMTP`, `TCP`, `UDP`, `IP` 等等组成

### TCP/IP 的组成
* TCP/IP 由以下几部分组成:
  * 协议结构为: `应用层， 传输层，网络层，数据链路层，物理层` 【五层体系】
  * 体系结构为: `应用层， 传输层，网络层(网络互联层)，网络接口层` 【四层体系】

### TCP/IP 五层体系
* `应用层(Application Layer)`
  * 该模型将我们的 OSI 层中的 `应用层，表示层，会话层` 模块进行了合并，统一称之为`应用层`
  * 其本质就是实现的是通过不同的应用层协议为不同的应用提供对应的服务吧
    * `FTP`，`Telnet`，`DNS`，`SMTP`
* `传输层(Transport Layer)`
  * 该层实现的是我们的对上层实体提供源端到对端主机的通信功能
  * 传输层主要的两个协议类型: `传输控制协议TCP` 和 `用户数据报协议UDP`
    * TCP 协议是面向连接的，reliable，基于字节流的传输层通信协议，数据传输更加的可靠
    * UDP 协议是无连接的，unreliable，基于数据报的传输层通信协议，数据传输见简单，并且更加的快速
* `网络层(Network Layer)`
  * 负责的是分组网络中的不同主机提供通信服务，并且选择合适的路由将数据传递到目标主机
  * 在发送数据的时候，网络层`把传输层产生的报文段和用户数据封装成分组和包进行传送`
* `数据链路层(Data Link Layer)`
  * 数据链路层在两个相邻节点间传输数据时，`将网络层交下来的 IP 数据组装成帧，在两个节点之间的链路上进行传输`
* `物理层(Physical Layer)`
  * 让硬件工程师来解释，这里忽略，不做讲解

### TCP/IP 四层体系
![img.png](/img.png)

---
## TCP 和 UDP 对比
### UDP 
* UDP (User Datagram Protocol)，用户数据报协议，是一个简单的面向数据报的通信协议
  * 也就是说对应用层传递下来的数据是不进行合并和拆分的，只是在其上面添加首部后就直接交给了网络层的一种协议类型
  * 也就是说我们的无论应用层交给 UDP 多长的报文，都是统一进行发送的呐，一次发送一个报文
  * 同时在对端接收到了数据直接进行去除首部，交给应用层即可

![img01](/img_1.png)

### TCP
* TCP (Transmission Control Protocol)，传输控制协议，是一个面向连接的、可靠的、基于字节流的传输层通信协议
  * 对于我们的 TCP 协议来说的话，只有等待数据包完全的时候才会发送数据的，否则就不会进行发送我们的数据的呐
  * 发送数据的过程中具备的一些特性有
    * 校验和
    * 序列号
    * 确定应答
    * 重发控制
    * 连接管理
    * 窗口控制

![img02](/img_2.png)

### 区别
![img03](/img_3.png)
* 面向区别
  * TCP 是面向连接的
  * UDP 是无连接的
* 连接区别
  * TCP 连接的时候有 3 次握手，断开的时候有四次挥手; 
  * UDP 是不需要进行建立连接的，发送数据端只需要进行发送数据到网络层中，接收端从消息队列读取消息即可
* 正确性
  * TCP 在传输过程中会采用流量控制，编号与确认计时器登手段保证数据的正确性，数据不丢失的
  * UDP 没有保证数据的正确性，数据有可能丢失，同时也不能保证对方是否可以收到
* 通信准则
  * TCP 是一个全双工通讯
  * UDP 可以支持的是一对一，一对多，多对一，多对多的交互通信

---
## TCP 三次握手和四次挥手
### 三次握手(Three Way Handshake)
* 三次握手实际上是在建立 TCP 连接的时候，需要客户端和服务器总共发送 3 个包
  * 主要是为了确保双方接收能力和发送能力是正常的呐，指定自己的初始化序号，为后续的可靠性传送做准备吧
* 具体过程
  * `第一次握手`: 客户端向服务端发送一个 SYN 报文，并且指明客户端初始化的 ISN(c)，此时客户端处于 SYN_SENT 状态
  * `第二次握手`: 服务端收到了客户端的 SYN 报文，会以自己的 SYN 报文作为回答，为了确认客户端的信息身份，将客户端的 ISN + 1 作为ACK的值，此时服务器处于 SYN_RCVD 状态
  * `第三次握手`: 客户端收到服务端的 SYN 报文，并且以自己的 ACK 报文作为回答，此时客户端处于 ESTABLISHED 状态，此时服务端也会进入 ESTABLISHED 状态，最终建立连接成功
* 通过三次握手可以确保连接建立成功，以及确保客户端和服务端接收和发送功能的正常状态
* `为什么不是两次握手呐？？？`
  * 如果是两次握手的话，可以确保的是发送方的发送功能的正常，也能确定对方接收到了信息，但是少了一个步骤，就是确定对方接收到了信息
  * 两次握手的话，可能导致的就是网络阻塞等原因发送多个请求报文，延迟达到的请求又会和服务端建立连接，浪费了额外的服务器的资源吧

![img04](/img_4.png)

### 四次挥手(Four Way Handshake)
* TCP 终止一个连接的时候需要四次挥手
* 具体过程
  * `第一次挥手`: 客户端向服务端发送一个 FIN 报文，此时客户端处于 FIN_WAIT_1 状态，停止发送数据，并且等待服务端的回复
  * `第二次挥手`: 服务端收到客户端的 FIN 报文，并且回复一个 ACK 报文，此时服务端处于 CLOSE_WAIT 状态，并且等待客户端的回复
  * `第三次挥手`: 客户端收到服务端的 ACK 报文，并且回复一个 ACK 报文，此时客户端处于 FIN_WAIT_2 状态，并且等待服务端的回复，此时服务端会进入 LAST_ACK 状态，并且等待客户端的回复
  * `第四次挥手`: 服务端收到客户端的 ACK 报文，此时服务端处于 CLOSED 状态，并且关闭连接
* 四次挥手原因
  * 服务端接收到了客户端的 FIN 报文后，并不会立即关闭连接，而是会进入一个中间状态，
  * 等待客户端的回复，此时客户端会进入 TIME_WAIT 状态，并且等待服务端的回复，此时服务端会进入 CLOSED 状态，并且关闭连接

![img05](/img_5.png)

---
## HTTP Get 请求和 POST 请求
### 是什么？？
* 都是 http 协议中发送网络请求的方法
* GET 请求时为了请求一个指定资源的表示形式，从而获取得到数据的请求方式
* POST 请求时为了向服务器提交一个请求，从而向服务器提交数据的请求方式，POST 请求会对服务器有一定的副作用吧
* 两个请求本质上都是我们的 http 协议的请求方法，以及都是 TCP 连接的呐

### 区别
* GET 请求在浏览器回退的时候时无害的，但是 POST 请求会再次发送对应的请求吧
* GET 请求产生的 URL 地址可以被 BookMark 记录，POST 请求则不可以
* GET 请求会被浏览器主动缓存 cache 的，但是 POST 请求不会，需要额外的手动配置吧
* GET 请求是能进行 URL 编码，而 POST 支持多种形式的数据
* GET 请求的记录被完全的保存在浏览器记录里的，而 POST 请求则不会保存
* GET 请求的 URL 地址是具备长度限制的呐。POST 请求没有
* GET 请求只能接收 ASCII 字符，而 POST 请求可以接收任何字符
* GET 请求相对而言数据是明文传递的，所以说没有 POST 请求安全，所以说传输铭感数据的话使用 POST 请求
* GET 请求参数通过 URL 传递，POST 请求传递数据通过 Request body 传递

### 具体区别
* `参数位置`
  * 不携带参数进行发送请求时候，两者最大的区别就是请求方法不同
  * 当携带参数的时候发送请求时，GET 请求的参数会拼接在 URL 后面，POST 请求的参数会放在 Request Body 中
    * 但是需要注意的是，我们的 GET 请求的话也是可以通过 Body 来实现传递数据的呐，只是约定的是通过 QUERY_PARAMS 来传递参数
* `参数长度`
  * http 协议本身对 Body 和 URL 是没有长度限制的，对 URL 的限制大多数来自于浏览器和服务器之间吧
  * 除了 IE 以外，其他的浏览器理论上对 URL 的长度没有限制，但是 IE 浏览器对 URL 的长度有限制，一般限制在 `2048 + 35` 个字符左右
  * 服务器对于处理较长的 URL 的时候需要花费比较多的资源，性能就不行了
* `安全`
  * POST 请求从表观上比 GET 请求更加安全，因为数据在地址栏中是明文的
  * 但是从传输过程来说的话，他奶奶的都是不安全的，因为 Http 在网络上的数据传输是明文的呐，只要在网络上进行了捉包，那么还是不安全的
  * 所以说这就是为什么我们现在使用的是 https 协议，因为 https 协议是加密的
* `数据包`
  * GET 请求的时候，浏览器会把 `http-header 和 data 一并进行发送，服务器返回 200 说明响应数据成功吧`
  * POST 请求的时候，`浏览器先发送 header 部分，等待服务器响应100后，浏览器才再次发送 data，服务器最终响应 200-ok`，firefox 除外

---
## HTTP 请求头
> * HTTP 头字段（HTTP header fields）,是指在超文本传输协议 HTTP 的请求和响应信息中的消息头部分
> * 他们定义了一个超文本传输协议事务中操作参数
> * HTTP头部字段可以自己根据具体的需求进行自定义吧，这些都是规范好了的

### Http header 分类
* `Accept` 客户端能够接收回应内容类型，`Accept: text/plain`
* `Accept-Charset` 客户端能够接收的字符集，`Accept-Charset: utf-8`
* `Accept-Encoding` 客户端能够接收的编码类型，`Accept-Encoding: gzip, deflate`
* `Accept-Language` 客户端能够接收的语言类型，`Accept-Language: zh-CN,zh;q=0.9`
* `Accept-Ranges` 客户端能够接收的分块范围，`Accept-Ranges: bytes`
* `Authorization` 客户端认证信息，`Authorization: Basic YWRtaW46YWRtaW4=` 还有其他的认证方式
* `Cache-Control` 客户端缓存控制，`Cache-Control: no-cache`
* `Connection` 客户端连接类型，`Connection: keep-alive`
* `Cookie` 客户端 cookie 信息，服务端设置的，`Cookie: name=value`
* `Content-Length` 客户端请求体长度，`Content-Length: 100`
* `Content-Type` 客户端请求体类型，`Content-Type: application/json`
* `Date` 客户端请求时间，`Date: Wed, 21 Oct 2015 07:28:00 GMT`
* `Expect` 客户端期望响应结果，`Expect: 100-continue`
* `From` 客户端请求者信息，`From: user@example.com`
* `Host` 客户端请求主机信息，`Host: www.example.com`
* `If-Match` 客户端请求资源是否匹配，`If-Match: "737060cd8c284d8af7ad3082f209582d"`
* `If-Modified-Since` 客户端请求资源是否被修改，`If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT`
* `If-None-Match` 客户端请求资源是否匹配，`If-None-Match: "737060cd8c284d8af7ad3082f209582d"`
* `If-Range` 客户端请求资源是否范围请求，`If-Range: "737060cd8c284d8af7ad3082f209582d"`
* `If-Unmodified-Since` 客户端请求资源是否被修改，`If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT`
* `Max-Forwards` 客户端请求最大转发数，`Max-Forwards: 10`
* `Origin` 客户端请求来源，`Origin: http://www.example.com`
* `Pragma` 客户端请求pragma，`Pragma: no-cache`
* `Proxy-Authorization` 客户端代理认证信息，`Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`
* `Range` 客户端请求范围，`Range: bytes=0-100`
* `Referer` 客户端请求来源，`Referer: http://www.example.com/index.html`
* `TE` 客户端请求传输编码，`TE: trailers`
* `Upgrade` 客户端请求升级协议，`Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11`
* `User-Agent` 客户端请求用户代理，`User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.78 Safari/537.36`
* `Via` 客户端请求经过的代理服务器，`Via: 1.0 fred, 1.1 example.com (Apache/1.1)`
* `Warning` 客户端请求警告信息，`Warning: 199 Miscellaneous warning`
* `X-Requested-With` 客户端请求来源，`X-Requested-With: XMLHttpRequest`

### 协商缓存
* 协商缓存利用的就是我们的 `Last-Modified， If-Modified-Since， ETag， If-None-Match` 字段
* `Last-Modified`: 表明的是本地文件最后被修改时间，浏览器会在 request header 上加上 `If-Modified-Since` 字段（上次返回的时间），
  * 询问服务器是否有更新，有更新就会将新的资源返回，没有更新就会返回 304
* `Etag`: 是资源的一个指纹，资源一旦变化就会导致对应的指纹的变化，和最后的修改时间无关，`Etag` 可以保证我们的资源是唯一的，不会被篡改
* `If-Modified-Since`: 客户端请求资源是否被修改，如果被修改了，就会返回 200，如果没有被修改，就会返回 304
* `If-None-Match`: 客户端请求资源是否匹配，如果匹配了，就会返回 200，如果没有匹配，就会返回 304，会携带上上次的 `Etag`

### 强制缓存
* 就不需要通过我们的服务器请求校验了，根据请求头的 `expires` 字段 和 `cache-control` 字段来实现判断命中缓存的

### 会话状态
* 会话状态就是指客户端与服务器之间需要维护的状态，比如登录状态，购物车状态，会话状态就是指客户端与服务器之间需要维护的状态
* `cookie` 字段来实现的我们的会话状态的维持吧，该信息用于服务端辨别用户身份而存储在用户本地终端上的数据吧，服务器设置的
* `cookie` 类别
  * `内存-cookie`
    * 是指在浏览器内存中存储的 cookie，当浏览器关闭时，内存中的 cookie 会被清除，但是当浏览器重新打开时，内存中的 cookie 会重新加载到浏览器中
  * `持久化-cookie`
    * 指的是保存在我们的硬盘中的数据吧，服务端是可以设置 cookie 的有效时间的
    * 当人为的手动删除 cookie 或者 cookie 过期了之后，我们的 cookie 就会失效了，
    * 这个时候客户端就需要向服务端重新发送请求，获取 cookie 了
    * 服务端的 cookie 过期时间一般是 14day 吧，django 中的默认是 14day
  * `判断内存和持久化`
    * 服务端没有设置 cookie 的过期时间，那么就是内存-cookie，这个时候在浏览器关闭的时候，自动清除
    * 服务端设置了 cookie 的过期时间，那么就是持久化-cookie，这个时候在浏览器关闭的时候，不会自动清除，需要手动删除

---
## HTTP 状态码
> * http状态码（http status code）用来表示的是网页服务器超文本传输协议响应状态的3位数字吧
> * http状态码 的作用就是我们的服务器告诉客户端当前请求的状态，客户端通过状态码来判断和分析服务器的运行状态吧

### 1xx
* 100 客户端继续发送请求，服务器继续处理，这个是我们的临时请求吧
  * 这个临时的请求是用来通知客户端他的部分请求已经被服务器接收了，且并没有被拒绝，客户端应当继续发送完剩余的请求给服务端吧
* 101 切换协议，客户端要求服务器切换协议，服务器同意切换协议，那么就会返回这个状态码，主要是用于 websocket 和 http2.0 中吧

### 2xx
* 200 请求成功，服务器已经接受到客户端的请求，并成功处理了，客户端可以继续发送请求，也可以关闭连接了
* 201 创建成功，服务器已经创建了一个新的资源，客户端可以继续发送请求，也可以关闭连接了
* 202 请求已经接受，但处理中，客户端可以继续发送请求，也可以关闭连接了
* 204 请求成功，服务器已经接受到客户端的请求，但没有返回任何内容，客户端可以继续发送
* 206 响应部分内容，服务器已经接受到客户端的请求，但返回的是部分内容，客户端可以继续发送请求，也可以关闭连接了

### 3xx
* 300 重定向，服务器已经接受到客户端的请求，但需要客户端进行重定向，客户端可以继续发送请求，也可以关闭连接了
* 301 永久重定向，服务器已经接受到客户端的请求，但需要客户端进行永久重定向，客户端可以继续发送请求，也可以关闭连接了
* 302 临时重定向，服务器已经接受到客户端的请求，但需要客户端进行临时重定向，客户端可以继续发送请求，也可以关闭连接了
* 304 资源未修改，服务器已经接受到客户端的请求，但资源未修改，客户端可以继续发送请求，也可以关闭连接了
* 307 重定向，服务器已经接受到客户端的请求，但需要客户端进行307重定向，客户端可以继续发送请求，也可以关闭连接了

### 4xx
* 400 客户端请求错误，服务器已经接受到客户端的请求，但请求有语法错误，客户端可以继续发送请求，也可以关闭连接了
* 401 未授权，服务器已经接受到客户端的请求，但请求未授权，客户端可以继续发送请求，也可以关闭连接了
* 403 禁止访问，服务器已经接受到客户端的请求，但请求被禁止访问，客户端可以继续发送请求，也可以关闭连接了
* 404 资源不存在，服务器已经接受到客户端的请求，但资源不存在，客户端可以继续发送请求，也可以关闭连接了
* 405 方法不允许，服务器已经接受到客户端的请求，但请求的方法不允许，客户端可以继续发送请求，也可以关闭连接了
* 407 代理认证失败，服务器已经接受到客户端的请求，但代理认证失败，客户端可以继续发送请求，也可以关闭连接了
* 408 请求超时，服务器已经接受到客户端的请求，但请求超时，客户端可以继续发送请求，也可以关闭连接了
* 409 冲突，服务器已经接受到客户端的请求，但请求冲突，客户端可以继续发送请求，也可以关闭连接了

### 5xx
* 500 服务器内部错误，服务器已经接受到客户端的请求，但服务器内部错误，客户端可以继续发送请求，也可以关闭连接了
* 501 服务器不支持该请求，服务器已经接受到客户端的请求，但服务器不支持该请求，客户端可以继续发送请求，也可以关闭连接了
* 502 服务器错误，服务器已经接受到客户端的请求，但服务器错误，客户端可以继续发送请求，也可以关闭连接了
* 503 服务器过载，服务器已经接受到客户端的请求，但服务器过载，客户端可以继续发送请求，也可以关闭连接了
* 504 服务器超时，服务器已经接受到客户端的请求，但服务器超时，客户端可以继续发送请求，也可以关闭连接了
* 505 HTTP版本不受支持，服务器已经接受到客户端的请求，但HTTP版本不受支持，客户端可以继续发送请求，也可以关闭连接了

---
## HTTP 和 HTTPS
### HTTP
* HTTP -- HyperText Transfer Protocol，超文本运输协议，是实现网络通信的一种规范

![img06](/img_6.png)
* 计算机网络中的协议类型含有
  * `广播协议，寻址协议，路由协议，传输协议`
  * HTTP 就是一种传输协议吧
* 在进行传输数据的时候并不是计算机底层的二进制包，是一些具有实际意义的二进制数据吧
  * HTML文件，图片文件，查询结果超文本
  * HTTP 传输协议的话是一个十分常用的传输协议了，其本身的话是以明文形式进行的传输数据，不提供任何的加密方式吧，所以说不太安全
  * 在传输过程中，我们的传输的数据类型的话，会使用 `Content-Type` 进行标记吧
  * 无连接的特点: HTTP 是无连接的协议，即一次请求对应一次响应，即一次请求对应一次连接，一次响应对应一次断开连接
  * 无状态的特点: HTTP 是无状态的协议，无法根据之前的状态进行本次的请求处理吧

### HTTPS
* HTTPS 的出现就是为了保证 HTTP 传输协议的安全性的呐
* 其本质原理就是将我们的数据的传输运行在 `SSL/TLS` 协议中，HTTPS = HTTP + SSL/TLS
  * 通过我们的 SSL（Secure Socket Layer） 证书进行验证服务端身份，并且为浏览器和服务器之间的通信进行加密吧

### 区别
* HTTPS 是更加安全的HTTP传输协议，HTTPS 使用的加密准者就是我们的 SSL/TSL 协议来实现的加密处理，相对而言更加的安全吧
* HTTP 和 HTTPS 使用的连接不同（HTTPS 多了一个服务器颁发证书的步骤吧），默认的端口也不同的，HTTP 的默认端口是80，HTTPS 的默认端口是443
* HTTPS 需要设置加密以及多次握手，性能方面不及 HTTP
* HTTPS 需要设置证书，需要申请证书，需要花费一定的费用

---
## HTTP 不同版本
### HTTP/0.9
* 最原始的 HTTP 版本

### HTTP/1.0
* HTTP/1.0 是 HTTP 第二个版本，指的是在我们的浏览器和服务端之间只保持短暂的连接，每次的请求都是需要进行建立新的 TCP 连接的
* 只要服务器处理完了某次请求，那么本次 TCP 连接就关闭了，相当于在这个过程中需要进行大量的创建连接和关闭连接的操作吧
  * 但是如何需要持久化的连接，需要手动设置 `Connection: keep-alive`

### HTTP/1.1
* HTTP/1.1 是 HTTP 第三个版本，
* 指的是我们的浏览器和服务端之间可以保持持久化的连接，也就是可以进行多次的请求和响应的，并且可以进行多次的请求和响应的，并且可以进行多次
* 减少了关闭和建立连接带来的不必要的性能消耗
  * 引入了更多的缓存控制策略
  * 引入了 range 运行请求资源的某个部分
  * 引入了 host ，实现了在一台 web 服务器的基础上可以在使用同一个 IP 地址和端口号的情况上使用不同的主机名来创建多个虚拟 web 站点

### HTTP/2
* 实现了我多路复用
* 实现了二进制分帧
* 实现了首部压缩
* 实现了服务器推送

---
## HTTPS 加密方式
### 原理
* 最主要的就是使用我们的 HTTP + SSL/TLS 协议来实现的加密处理，本质上就是处理了我们的相关的证书问题吧

### 对称加密
* 采用的是协商的密钥对对数据进行的加密吧
* 对称加密本质是: 服务器与客户端之间进行加密的密钥是相同的,是对称的

![img07](/img_7.png)

### 非对称加密
* 就是值得是我们的加密使用的密钥对的话是一对的，一个是公钥，一个是私钥，两个密钥是不同的呐
* 公钥是可以给任何人进行使用的呐，但是私钥一定需要进行保密保管吧
  * 公钥和密钥都是可以用来进行对其加密的

![img08](/img_8.png)

### 混合加密
* 采用的是`对称加密`和`非对称加密`的混合加密，即先使用非对称加密，然后使用对称加密

![img09](/img_9.png)

### 摘要算法
* 散列算法（哈希函数），就是将我们的数据进行散列处理，然后进行加密

### 签名算法(数字签名)
* 签名算法就是对数据进行加密，然后进行签名，然后进行验证

![img10](/img_10.png)

```shell
#!/usr/bin/env bash
# 生成私钥
openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:204
# 生成公钥
openssl rsa -in private_key.pem -pubout -out public_key.pem
```

---
## CDN 缓存
### CDN 是什么呐？？
* CDN（Content Delivery Network），内容分发网络
  * 是构建在现有的网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过`中心平台的负载均衡、内容分发、调度等功能模块，`
  * 从而实现我们的`让用户从最近的服务器获取所需资源`，`降低网络拥塞，提高用户访问响应速度和命中率的`
  * `CDN` 的关键点就是我们的`内存存储和分发技术`的使用吧
* 从表观上进行记忆的话就是
  * 用户可以不从源站源头获取所需资源，而是通过`访问最近的一个 CDN 站点来获取资源`的呐
  * 这个节点也是我们的`边缘节点`吧，从本质上来说的话就是`缓存了源站内容的代理服务器罢了`

![img11](/img_11.png)

### CDN 原理
* 在没有使用内容分发技术前一个用户访问网站的流程是:
  * 用户提交域名 --> 浏览器对域名进行解析 --> DNS解析得到目的主机的IP地址
  * --> 根据获取得到的 IP 地址发出请求获取资源 --> 服务器处理请求并返回资源
* 在进行实现使用我们的 CDN 技术后，我们的 `DNS 解析返回的就不再是 IP 地址了，这个时候而是我们的 CNAME(Canonical Name) 别名记录`
  * 指向 CDN 的全局负载均衡吧
* CNAME 实际上来域名解析的过程中承担了代理（中间人）的角色吧，这个是 CDN 技术的核心所在吧

### 负载均衡系统
* 由于我们的 DNS 解析没有返回具体的 IP 地址，返回的是我们的 CNAME，这个时候本地的 DNS 就会向负载均衡系统再次发送请求
* 最终就是实现的是进入到 CDN 的全局负载均衡系统中进行对应的智能调度
  * 首先先获取得到用户的 IP 地址，查看得到用户所在的地理位置，从而寻址得到用户所在地区最近的边缘节点
  * 然后看用户所在的运营商网络，找到对应的相同的边缘节点
  * 检查边缘节点的负载均衡情况，找到负载最轻的节点
* 就是结合这些因素的考虑，从而实现为用户返回最为合适的边缘节点，然后将我们的这个节点返回给用户吧，用户这个时候就可以访问 CDN 的缓存代理了

![img12](/img_12.png)

### 缓存代理
* 缓存系统是 CDN 服务的另一个十分重要的核心组件，缓存系统会进行合理的选择将用户的什么资源进行缓存起来的
* 其中的两个比较重要的衡量 CDN 服务质量的指标
  * `命中率`: 用户访问的资源恰好在缓存系统中，那么就直接返回给用户。就是命中次数和访问次数之比
  * `回源率`: 缓存系统中不具备资源，那么就必须用代理的方式回源站中获取资源，回源次数和访问次数之比
* 缓存系统的划分
  * 一级缓存节点: 一级缓存是直接联系源站的，配置方面相对较高
  * 二级缓存节点: 二级缓存是直连用户的，配置相对较低

### 总结
* CDN 缓存系统主要的目的还是提高自身的互联网服务质量的呐，体现出来的就是提高了用户的访问速度吧
  * 根据用户自身的一些信息，寻找到最为合适的节点，从而达到为用户最佳服务策略了吧
* CDN 构建了全国甚至是全球级别的专网，让用户就近访问专网内的边缘节点，降低了传输延迟，从而实现了网站加速
* CDN 
  * `负载均衡系统相当于是整个 CDN 的智能调度的核心吧，就是这整套系统的核心大脑了吧，智能的给用户分配 CDN 边缘节点的决策官`
  * `缓存系统就是 CDN 的心脏了吧，缓存命中后直接返回给用户，否则进行回源，从源站获取资源`
* 这些就都是后端需要进行做的事情了，前端了解基本流程和原理即可吧

## DNS 协议
### DNS 协议是什么
* DNS(Domain Name System), 域名系统，是互联网的一项服务，时进行域名和与之对应的 IP 地址进行转换的服务器吧
* 简单来说，DNS 就是一个翻译官，将我们平时访问资源的 URL 地址的域名进行合理的解析，获取得到对应的 IP 地址或者说 CNAME 的
  * IP 地址: 一长串能够唯一标识服务器资源的数字吧
  * 域名: 是一串用点分割的名字祖传的 Internet 上某一台计算机或者计算机组的名称，用于数据传输时对计算机的定位标识标识吧
* 我们平时在访问某个资源的时候，可以做的是: 
  * 输入服务器的IP地址来实现获取对应的资源吧
  * 输入域名来获取对应的服务器资源吧

![img13](/img_13.png)

### 域名是什么呐？？？
* 域名具备一定的层次结构的呐，从上到下依次为: `根域名，顶级域名，二级域名，三级域名...`

![img14](/img_14.png)
* www.juwenzhang.com
  * `www` 就是三级域名
  * `juwenzhang` 就是二级域名
  * `com` 就是顶级域名
  * `.` 一般是忽略了的，但是是具备的呐，这个就是根域名

### DNS 查询方式
* DNS 查询方式分为两种:
  * 递归查询: 递归查询就是从本地的 DNS 服务器开始查询，如果查询不到就继续向根域名服务器查询，直到查询到为止
![img15](/img_15.png)

  * 迭代查询: 就是请求者不会有具体的请求，服务器之后告诉你如何去发送接下来的请求，但是自己并不会去请求的呐
![img16](/img_16.png)

### 域名缓存
* 在域名服务器进行解析的时候，使用缓存保存`域名和 IP 地址的映射关系`
* 计算机的 DNS 记录分为两种缓存形式
  * `浏览器缓存`: 浏览器在获取网站域名的实际IP地址后会对其进行缓存，减少网络请求带来的消耗吧
  * `操作系统缓存`: 操作系统缓存其实就是我们的用户自己配置的 `hosts` 文件吧

### DNS 查询过程
* 首先是搜索浏览器的 DNS 缓存，缓存中存在维护者`域名和IP地址的映射表`吧
* 如果没有命中，那么就继续搜索操作系统的 DNS 缓存
* 若任然没有命中，则操作系统将域名发送至本地的域名服务器，本地的域名服务器采用递归查询自己的 DNS 缓存，查询成功则返回结果
* 若本地的域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
  * 首先本地的服务器向根域名服务器发送请求，根域名服务器返回顶级域名服务器的地址给本地服务器
  * 本地域名服务拿着这个顶级域名服务器的地址后，就向其发送请求，获取权限服务器的地址
  * 本地域名服务器拿着权限域名服务器的地址向其发送请求，最终得到该域名对应的 IP 地址即可
* 本地域名服务器将得到的 IP 地址返回给操作系统后，同时自己将 IP 地址进行缓存起来
* 操作系统将 IP 地址返回给浏览器，同时浏览器将 IP 地址进行缓存
* 此时浏览器缓存就多了一个 `域名和IP地址的映射表`

![img17](/img_17.png)